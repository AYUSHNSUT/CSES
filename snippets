{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }

	"C++ default template": {
		"prefix": "_codechef",
		"body": [
		  "#include<bits/stdc++.h>",
		  "//#include <ext/pb_ds/assoc_container.hpp>",
		  "//using namespace __gnu_pbds;",
		  "using namespace std;",
		  "#define DEBUG(x) cerr << '>' << #x << ':' << x << endl;",
		  "#define REP(i,n) for(int i=0;i<(n);i++)",
		  "#define FOR(i,a,b) for(int i=(a);i<=(b);i++)",
		  "#define FORD(i,a,b) for(int i=(a);i>=(b);i--)",
		  "#define all(c) c.begin(),c.end()",
		  "#define M 1000000007",
		  "typedef long long ll;",
		  "typedef unsigned long long ull;",
		  "typedef pair<int, int> pii;",
		  "typedef pair<ll, ll> pll;",
		  "typedef pair<string, string> pss;",
		  "typedef vector<int> vi;",
		  "typedef vector<vi> vvi;",
		  "typedef vector<pii> vii;",
		  "typedef vector<ll> vl;",
		  "typedef vector<vl> vvl;",
		  "#define mp make_pair",
		  "#define pb push_back",
		  "inline bool EQ(double a, double b) { return fabs(a-b) < 1e-9; }",
		  "inline int two(int n) { return 1 << n; }",
		  "inline int test(int n, int b) { return (n>>b)&1; }",
		  "inline void set_bit(int & n, int b) { n |= two(b); }",
		  "inline void unset_bit(int & n, int b) { n &= ~two(b); }",
		  "inline int last_bit(int n) { return n & (-n); }",
		  "inline int ones(int n) { int res = 0; while(n && ++res) n-=n&(-n); return res; }",
		  "template<class T> void chmax(T & a, const T & b) { a = max(a, b); }",
		  "template<class T> void chmin(T & a, const T & b) { a = min(a, b); }",
		  "#define fast_cin() std::ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)",
		  "//#undef _GLIBCXX_DEBUG",
		  "// uncomment for multiset and us less_equal in line below",
		  "//#define indexed_set tree<int,null_type,less<int>,rb_tree_tag, tree_order_statistics_node_update> ",
		  "",
		  "/////////////////////////////////////////////////////////////////////////",
		  "/////////////////////////////////////////////////////////////////////////",
		  "// ⡏⠉⠉⠉⠉⠉⠉⠋⠉⠉⠉⠉⠉⠉⠋⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠙⠉⠉⠉⠹",
		  "// ⡇⢸⣿⡟⠛⢿⣷⠀⢸⣿⡟⠛⢿⣷⡄⢸⣿⡇⠀⢸⣿⡇⢸⣿⡇⠀⢸⣿⡇⠀",
		  "// ⡇⢸⣿⣧⣤⣾⠿⠀⢸⣿⣇⣀⣸⡿⠃⢸⣿⡇⠀⢸⣿⡇⢸⣿⣇⣀⣸⣿⡇⠀",
		  "// ⡇⢸⣿⡏⠉⢹⣿⡆⢸⣿⡟⠛⢻⣷⡄⢸⣿⡇⠀⢸⣿⡇⢸⣿⡏⠉⢹⣿⡇⠀",
		  "// ⡇⢸⣿⣧⣤⣼⡿⠃⢸⣿⡇⠀⢸⣿⡇⠸⣿⣧⣤⣼⡿⠁⢸⣿⡇⠀⢸⣿⡇⠀",
		  "// ⣇⣀⣀⣀⣀⣀⣀⣄⣀⣀⣀⣀⣀⣀⣀⣠⣀⡈⠉⣁⣀⣄⣀⣀⣀⣠⣀⣀⣀⣰",
		  "// ⣇⣿⠘⣿⣿⣿⡿⡿⣟⣟⢟⢟⢝⠵⡝⣿⡿⢂⣼⣿⣷⣌⠩⡫⡻⣝⠹⢿⣿⣷",
		  "// ⡆⣿⣆⠱⣝⡵⣝⢅⠙⣿⢕⢕⢕⢕⢝⣥⢒⠅⣿⣿⣿⡿⣳⣌⠪⡪⣡⢑⢝⣇",
		  "// ⡆⣿⣿⣦⠹⣳⣳⣕⢅⠈⢗⢕⢕⢕⢕⢕⢈⢆⠟⠋⠉⠁⠉⠉⠁⠈⠼⢐⢕⢽",
		  "// ⡗⢰⣶⣶⣦⣝⢝⢕⢕⠅⡆⢕⢕⢕⢕⢕⣴⠏⣠⡶⠛⡉⡉⡛⢶⣦⡀⠐⣕⢕",
		  "// ⡝⡄⢻⢟⣿⣿⣷⣕⣕⣅⣿⣔⣕⣵⣵⣿⣿⢠⣿⢠⣮⡈⣌⠨⠅⠹⣷⡀⢱⢕",
		  "// ⡝⡵⠟⠈⢀⣀⣀⡀⠉⢿⣿⣿⣿⣿⣿⣿⣿⣼⣿⢈⡋⠴⢿⡟⣡⡇⣿⡇⡀⢕",
		  "// ⡝⠁⣠⣾⠟⡉⡉⡉⠻⣦⣻⣿⣿⣿⣿⣿⣿⣿⣿⣧⠸⣿⣦⣥⣿⡇⡿⣰⢗⢄",
		  "// ⠁⢰⣿⡏⣴⣌⠈⣌⠡⠈⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣬⣉⣉⣁⣄⢖⢕⢕⢕",
		  "// ⡀⢻⣿⡇⢙⠁⠴⢿⡟⣡⡆⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣵⣵⣿",
		  "// ⡻⣄⣻⣿⣌⠘⢿⣷⣥⣿⠇⣿⣿⣿⣿⣿⣿⠛⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
		  "// ⣷⢄⠻⣿⣟⠿⠦⠍⠉⣡⣾⣿⣿⣿⣿⣿⣿⢸⣿⣦⠙⣿⣿⣿⣿⣿⣿⣿⣿⠟",
		  "// ⡕⡑⣑⣈⣻⢗⢟⢞⢝⣻⣿⣿⣿⣿⣿⣿⣿⠸⣿⠿⠃⣿⣿⣿⣿⣿⣿⡿⠁⣠",
		  "// ⡝⡵⡈⢟⢕⢕⢕⢕⣵⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣶⣿⣿⣿⣿⣿⠿⠋⣀⣈⠙",
		  "// ⡝⡵⡕⡀⠑⠳⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⢉⡠⡲⡫⡪⡪⡣",
		  "/////////////////////////////////////////////////////////////////////////",
		  "/////////////////////////////////////////////////////////////////////////",
		  "",
		  "",
		  "void solve(){",
		  "",
		  "}",
		  "",
		  "",
		  "",
		  "int main(){",
		  "",
		  "",
		  "",
		  "    #ifdef mishrable",
		  "    // for getting input from input.txt",
		  "    freopen(\"input.txt\", \"r\", stdin);",
		  "    // for writing output to output.txt",
		  "    freopen(\"output.txt\", \"w\", stdout);",
		  "    #endif",
		  "",
		  "",
		  "",
		  "   fast_cin();",
		  "   int t =1;",
		  "   cin >> t; ",
		  "   while(t--){",
		  "       solve();",
		  "   }",
		  "}"
		],
		"description": "C++ default template"
	  },

	  "Djikstra Large": {
		"prefix": "_djikstra_large",
		"body": [
		  "void djikstra(){",
		  "    ll n, m;",
		  "    cin >> n >> m;",
		  "    const ll factr = 2000001;",
		  "",
		  "",
		  "    vector <ll> done(n);",
		  "    ll nodesDone = 0;",
		  "    vector <ll> parent(n,-1);",
		  "    vector <ll> distance(n , (ll)1e19);",
		  "",
		  "    distance[0] = 0;",
		  "",
		  "    vvl G(n);",
		  "    unordered_map<ll,ll> cost;",
		  "    for(ll i = 0;i<m;i++){",
		  "        ll a , b;",
		  "        cin >> a >> b;",
		  "        G[a-1].pb(b-1);",
		  "        ll t;",
		  "        cin >> t;",
		  "        if(cost.find((a-1)*factr + b-1) == cost.end()){",
		  "            cost[(a-1)*factr + b-1] = t;",
		  "        }",
		  "        else{",
		  "            cost[(a-1)*factr + b-1] = min(cost[(a-1)*factr + b-1] , t);",
		  "        }",
		  "    }",
		  "",
		  "    priority_queue<pair<ll,ll> ,vector <pair<ll,ll>> , greater<pair<ll,ll>>> pq;",
		  "",
		  "    REP(i,n){",
		  "        pq.push({distance[i], i});",
		  "    }",
		  "    while(nodesDone!= n){",
		  "        pii selectedNode = pq.top();",
		  "        pq.pop();",
		  "        ll dist = selectedNode.first;",
		  "        ll node = selectedNode.second;",
		  "        if(done[node]) continue;",
		  "",
		  "",
		  "        for(auto nodeNeighbours : G[node]){",
		  "            if(cost[(ll)node * (ll)factr + (ll)nodeNeighbours] + distance[node] < distance[nodeNeighbours]){",
		  "                distance[nodeNeighbours] = cost[node * factr + nodeNeighbours] + distance[node] ;",
		  "                pq.push({distance[nodeNeighbours], nodeNeighbours});",
		  "                parent[nodeNeighbours] = node;",
		  "            }",
		  "        }",
		  "",
		  "        done[node] = 1;",
		  "        nodesDone++;",
		  "    }",
		  "",
		  "    REP(i,n){",
		  "        cout << distance[i] << \" \";",
		  "    }",
		  "}",
		  ""
		],
		"description": "Djikstra Large"
	  },

	  "Disjoint Set union": {
		"prefix": "_DSU",
		"body": [
		  "",
		  "class DSU{",
		  "    private:",
		  "    ll n;",
		  "    vector<int> parent;",
		  "    vector<int> rank;",
		  "",
		  "    public:",
		  "    DSU(): n(0){}",
		  "",
		  "    DSU(ll size): n(size){",
		  "        parent.resize(n+1);",
		  "        rank.resize(n+1);",
		  "        for(int i = 1;i<=n;i++){",
		  "            parent[i] = i;",
		  "        }",
		  "    }",
		  "",
		  "    ll root(ll x){",
		  "        if(parent[x]!=x){",
		  "            parent[x] = root(parent[x]);",
		  "        }",
		  "        return parent[x];",
		  "    }",
		  "",
		  "",
		  "    bool connected(ll x, ll y){",
		  "        root(x);",
		  "        root(y);",
		  "        return parent[x] == parent[y];",
		  "    }",
		  "",
		  "    void connect(ll x, ll y){",
		  "        if(connected(x,y)){",
		  "            return;",
		  "        }",
		  "",
		  "        if(rank[root(x)] < rank[root(y)]){",
		  "            parent[root(x)] = root(y);",
		  "            root(x);",
		  "            root(y);",
		  "        }",
		  "        else if(rank[root(x)] > rank[root(y)]){",
		  "            parent[root(y)] = root(x);",
		  "            root(x);",
		  "            root(y);",
		  "        }",
		  "",
		  "        else{",
		  "            parent[root(y)] = root(x);",
		  "            root(x);",
		  "            root(y);",
		  "            rank[root(x)]++;",
		  "        }",
		  "",
		  "",
		  "    }",
		  "};"
		],
		"description": "Disjoint Set union"
	  },

	  "Generic Segment tree": {
		"prefix": "_seg_tree",
		"body": [
		  "",
		  "class segmentTree{",
		  "    ll n;",
		  "    vl t;",
		  "",
		  "    ll combine(ll a, ll b){",
		  "        return max(a,b);",
		  "    }",
		  "",
		  "    void makeTree(vl &a , ll v, ll tl , ll tr){",
		  "        if(tl > tr) return;",
		  "        if(tl == tr){",
		  "            t[v] = a[tl];",
		  "            return;",
		  "        }",
		  "",
		  "        ll tm = (tl + tr) / 2;",
		  "        makeTree(a,2*v, tl, tm);",
		  "        makeTree(a,2*v + 1, tm + 1, tr);",
		  "        t[v] = combine(t[2*v], t[2*v + 1]);",
		  "    }",
		  "",
		  "       ll find(ll v, ll tl , ll tr, ll a, ll b){",
		  "        if(a>b || tl > b || tr < a){",
		  "            return LLONG_MIN;",
		  "        }",
		  "",
		  "        if(a<= tl && b >= tr){",
		  "            return t[v];",
		  "        }",
		  "",
		  "        ll tm = (tl + tr) / 2;",
		  "        return combine(find(2*v, tl,tm,a,b),find(2*v+1, tm+1,tr,a,b));",
		  "    }",
		  "",
		  "    void updateNodez(ll v, ll tl, ll tr, ll pos, ll newVal){",
		  "        if(tl > tr) return;",
		  "",
		  "        if(tl == tr){",
		  "            t[v] = newVal;",
		  "            return;",
		  "        }",
		  "",
		  "        ll tm = (tl + tr) / 2;",
		  "",
		  "        if(pos <= tm){",
		  "            updateNodez(2*v, tl, tm, pos,newVal);",
		  "        }",
		  "        else{",
		  "            updateNodez(2*v + 1, tm + 1, tr, pos,newVal);",
		  "        }",
		  "",
		  "        t[v] = combine(t[2*v], t[2*v+1]);",
		  "    }",
		  "    public:",
		  "    segmentTree(ll n) : n(n){",
		  "        t.resize(4*n, LLONG_MIN);",
		  "    }",
		  "",
		  "    void generate(vl &a){",
		  "        ll v = 1;",
		  "        makeTree(a,v,0,n-1);",
		  "    }",
		  "",
		  "    ll get(ll a , ll b){",
		  "        if(a > b){",
		  "            swap(a,b);",
		  "        }",
		  "        return find(1,0,n-1,a,b);",
		  "    }",
		  "",
		  "    void update(ll pos, ll newVal){",
		  "        ll tl = 0;",
		  "        ll tr = n-1;",
		  "        updateNodez(1,tl,tr,pos, newVal);",
		  "    }",
		  " ",
		  "",
		  "",
		  "};",
		  ""
		],
		"description": "Generic Segment tree"
	  },


	  "lazy segment tree": {
		"prefix": "_seg_sum_lazy",
		"body": [
		  "class segmentSumLazy{",
		  "    ll n;",
		  "    vl t;",
		  "    vl lazy;",
		  "    void makeTree(vl &a , ll v, ll tl , ll tr){",
		  "        if(tl > tr) return;",
		  "        if(tl == tr){",
		  "            t[v] = a[tl];",
		  "            return;",
		  "        }",
		  " ",
		  "        ll tm = (tl + tr) / 2;",
		  "        makeTree(a,2*v, tl, tm);",
		  "        makeTree(a,2*v + 1, tm + 1, tr);",
		  "        t[v] = t[2*v]+ t[2*v + 1] ;",
		  "    }",
		  " ",
		  "       ll findSum(ll v, ll tl , ll tr, ll a, ll b){",
		  "        if(a>b || tl > b || tr < a){",
		  "            return 0;",
		  "        }",
		  "        if(lazy[v]){",
		  "            t[v] += (tr - tl + 1) * lazy[v];",
		  " ",
		  "            if(tl!= tr){",
		  "                lazy[2*v] += lazy[v];",
		  "                lazy[2*v+1] += lazy[v];",
		  "            }",
		  "        }",
		  " ",
		  "        lazy[v] = 0;",
		  " ",
		  "        if(a<= tl && b>= tr){",
		  "            return t[v];",
		  "        }",
		  " ",
		  "        ll tm = (tl + tr) / 2;",
		  "        return findSum(2*v,tl, tm , a, b, tm)+findSum(2*v+1,tm+1, tr , a, b) ;",
		  "    }",
		  " ",
		  "    void updateNodez(ll v, ll tl, ll tr, ll a, ll b, ll newVal){",
		  "        if(tl > tr) return;",
		  "",
		  "       if(lazy[v]){",
		  "           t[v] += (tr - tl + 1) * lazy[v];",
		  " ",
		  "           if(tl != tr){",
		  "               lazy[2*v] += lazy[v];",
		  "               lazy[2*v+1] += lazy[v];",
		  "           }",
		  "       }",
		  "       lazy[v] = 0;",
		  "       ",
		  "       if(tl >b || tr < a) return;",
		  "       if(a <= tl && b >= tr){",
		  "           t[v] += (tr - tl + 1) * newVal;",
		  " ",
		  "           if(tl != tr){",
		  "               lazy[2*v] += newVal;",
		  "               lazy[2*v + 1] += newVal; ",
		  "           }",
		  " ",
		  "           return;",
		  "       }",
		  " ",
		  "       ll tm = (tl + tr) / 2;",
		  "       updateNodez(2*v, tl ,tm , a,b,newVal);",
		  "       updateNodez(2*v + 1 , tm+1, tr , a,b,newVal);",
		  " ",
		  "       t[v] = t[2*v] + t[2*v + 1];",
		  " ",
		  "    ",
		  "    }",
		  "    public:",
		  "    segmentSumLazy(ll n) : n(n){",
		  "        t.resize(4*n);",
		  "        lazy.resize(4*n);",
		  "    }",
		  " ",
		  "    void generate(vl &a){",
		  "        ll v = 1;",
		  "        makeTree(a,v,0,n-1);",
		  " ",
		  "   ",
		  "    }",
		  " ",
		  "    ll getSum(ll a , ll b){",
		  "        return findSum(1,0,n-1,a,b);",
		  "    }",
		  " ",
		  "    void update(ll a, ll b, ll newVal){",
		  "        ll tl = 0;",
		  "        ll tr = n-1;",
		  "        updateNodez(1,tl,tr,a,b, newVal);",
		  "    }",
		  " ",
		  " ",
		  " ",
		  "};"
		],
		"description": "lazy segment tree"
	  },
	  "Fenwick tree": {
		"prefix": "_fenwick_1D_sum",
		"body": [
		  "",
		  "class FT{",
		  "    ll n;",
		  "    vl tree;",
		  "    public:",
		  "        FT(ll n) : n(n){",
		  "            tree.resize(n+1);",
		  "        }",
		  "",
		  "    void add(ll pos,ll x){",
		  "        while(pos <= n ){",
		  "            tree[pos]+=x;",
		  "            pos+= pos&(-pos);",
		  "        }",
		  "",
		  "    }",
		  "",
		  "    ll sum(ll point){",
		  "        ll res = 0;",
		  "       // DEBUG(point);",
		  "",
		  "     ",
		  "        if(!point) return 0;",
		  "        while(point >= 1){",
		  "        //    DEBUG(point);",
		  "            res += tree[point];",
		  "            point -= point & (-point);",
		  "        }",
		  "        return res;",
		  "    }",
		  "};"
		],
		"description": "Fenwick tree"
	  },
	  "Heavy ligh decomposition": {
		"prefix": "_heavy_ligh",
		"body": [
		  "",
		  "class HeavyLight{",
		  "    ll n;",
		  "    vvl G;",
		  "    vl heavy;",
		  "    vl vals;",
		  "    vvl dp;",
		  "    vl head;",
		  "    vl subtreeSize;",
		  "    vl depth;",
		  "    vl occur, occuri;",
		  "",
		  "    ll timer;",
		  "    public:",
		  "",
		  "    void getQueries(ll q, segmentTree &S){",
		  "        for(int i = 0;i<q;i++){",
		  "         ll query;",
		  "         cin >> query;",
		  "         if(query == 1){",
		  "             ll s , x;",
		  "             cin >> s >> x;",
		  "",
		  "             S.update(occur[s],x);",
		  "         }",
		  "",
		  "         else{",
		  "             ll a , b;",
		  "             cin >> a >> b;",
		  "             cout << getMax(a,b,S) << \" \";",
		  "         }",
		  "     }",
		  "    }",
		  "",
		  "    HeavyLight(ll k,ll q){",
		  "",
		  "        n = k;",
		  "",
		  "        // DEBUG(n);",
		  "        // DEBUG(q);",
		  "        timer = 0;",
		  "        heavy.resize(n+1,-1);",
		  "        vals.resize(n+1);",
		  "        dp.resize(n+1,vl(20));",
		  "        head.resize(n+1);",
		  "        subtreeSize.resize(n+1,1);",
		  "        depth.resize(n+1);",
		  "        depth[0] = -1;",
		  "        occur.resize(n+1);",
		  "        G.resize(n+1);",
		  "",
		  "",
		  "         REP(i,n){",
		  "             cin >> vals[i+1];",
		  "     }",
		  "",
		  "",
		  "     REP(i,n-1){",
		  "         ll a , b;",
		  "         cin >>a >> b;",
		  "         G[a].pb(b);",
		  "         G[b].pb(a);",
		  "     }",
		  "",
		  "",
		  "     dfs(1,0);",
		  "     decompose(1,1);",
		  "     segmentTree S(n);",
		  "     vector <ll> arr(n);",
		  "     unordered_map <ll,ll> head_c;",
		  "     for(int i = 0;i<n;i++){",
		  "         arr[i] = vals[occuri[i]];",
		  "         ll hd = head[occur[i]];",
		  "         head_c[hd]++;",
		  "     }",
		  "",
		  "     S.generate(arr);",
		  "",
		  "     getQueries(q,S);",
		  "    }",
		  "",
		  "    void dfs(ll source,ll parent){",
		  "        ll mxchild = -1;",
		  "        dp[source][0] = parent;",
		  "        depth[source] = depth[parent] + 1;",
		  "        for(auto child :G[source]){",
		  "            if(child ^ parent){",
		  "                dfs(child,source);",
		  "                subtreeSize[source] += subtreeSize[child];",
		  "",
		  "                if(subtreeSize[child] > mxchild){",
		  "                    mxchild = subtreeSize[child];",
		  "                    heavy[source] = child; ",
		  "                }",
		  "            }",
		  "        }",
		  "    }",
		  "",
		  "    void decompose(ll source, ll head_g){",
		  "        // DEBUG(source);",
		  "        // DEBUG(head_g);",
		  "        // DEBUG(timer);",
		  "        head[source] = head_g;",
		  "        occur[source]  = timer++;",
		  "        occuri[timer-1] = source;",
		  "",
		  "        if(heavy[source]!= -1){",
		  "            decompose(heavy[source],head_g);",
		  "        }",
		  "        for(auto child : G[source]){",
		  "            if(child ^ dp[source][0] && child != heavy[source]){",
		  "                decompose(child, child);",
		  "            }",
		  "        }",
		  "    }",
		  "",
		  "    ll getMax(ll a, ll b, segmentTree &S){",
		  "        ll res = LLONG_MIN;",
		  "",
		  "        while(head[a] != head[b]){",
		  "            if(depth[head[a]] > depth[head[b]]){",
		  "                swap(a,b);;",
		  "            }",
		  "",
		  "        ll partial_ans = S.get(occur[b], occur[head[b]]);",
		  "        res = max(res,partial_ans);",
		  "",
		  "        b = dp[head[b]][0];",
		  "    }",
		  "",
		  "    if(depth[a] > depth[b]){",
		  "        swap(a,b);",
		  "    }",
		  "",
		  "    ll lastAns = S.get(occur[a],occur[b]);",
		  "    res = max(res,lastAns);",
		  "    return res;",
		  "    ",
		  "}",
		  "",
		  "",
		  "};"
		],
		"description": "Heavy ligh decomposition"
	  },

	  "Modular arithmetic toolkit": {
		"prefix": "_modular_arithmetic",
		"body": [
		  "const int MAXNUMBER = 1e6;",
		  "long long fact[MAXNUMBER + 1];",
		  "long long ifact[MAXNUMBER + 1];",
		  "long long inverse[MAXNUMBER + 1];",
		  "ll modpow(ll a , ll b, ll m = M){",
		  " ",
		  "    if(b == 0){",
		  "        return a;",
		  "    }",
		  "    if(b == 1){",
		  "        return a;",
		  "    }",
		  "    ll res = 1;",
		  "    while(b){",
		  "       if(b&1){",
		  "           res = (res%m * a%m)%m;",
		  "       } ",
		  "       a = (a%m * a%m) %m;",
		  "       b >>=1;",
		  "    }",
		  "    return res;",
		  "}",
		  " ",
		  "ll modInv(ll a, ll m = M){",
		  "    return modpow(a,m-2);",
		  "}",
		  "",
		  "void modFacts(ll n, ll m = M){",
		  "",
		  "    fact[0] = fact[1] = 1;",
		  "    for (int i = 2; i <= n; i++) {",
		  "    fact[i] = (fact[i - 1] * i) % m;",
		  "    }",
		  "",
		  "",
		  "    ifact[n] = modpow(fact[n], m - 2);",
		  "    for (int i = n - 1; i >= 0; i--) {",
		  "    ifact[i] = ((i + 1) * ifact[i + 1]) % m;",
		  "    }",
		  "",
		  "",
		  "    for (int i = 1; i <= n; i++) {",
		  "        inverse[i] = (fact[i - 1] * ifact[i]) % m;",
		  "    }",
		  "}",
		  "",
		  "void invPow(ll n,ll k , ll m = M){",
		  "    long long k_inverse[n + 1];",
		  "    k_inverse[0] = 1;",
		  "    long long k_inv = modpow(k, m - 2), cur = 1;",
		  "    for (int i = 1; i <= n; i++) {",
		  "        cur = (cur * k_inv) % m;",
		  "        k_inverse[i] = cur;",
		  "    }",
		  "}",
		  ""
		],
		"description": "Modular arithmetic toolkit"
	  },
	  "Rolling hash": {
		"prefix": "_rolling_hash_toolkit",
		"body": [
		  "vl hashedTargets1,hashedTargets2;",
		  "vl hashedString1,hashedString2;",
		  "unordered_map <ll,ll> primePower1;",
		  "unordered_map <ll,ll> primePower2;",
		  "ll p1 = 999999937;",
		  "ll p2 = 999999929;",
		  "ll A = 999999893;",
		  "void preprocess(unordered_map <ll,ll> &primePower, ll multiplier = 999999893, ll m = 999999937){",
		  "    primePower[0] = 1;",
		  "    for(int i = 1;i<=1e6;i++){",
		  "        primePower[i] = (primePower[i-1]*multiplier)%m;",
		  "    }",
		  "}",
		  "ll getHashedStringWhole(string &s, ll mod = p1,ll multiplier = 999999893){",
		  "    ll hashh = s[0];",
		  "  //  DEBUG(s);",
		  "  //  DEBUG(hashh);",
		  "",
		  "    for(int i = 1;i<s.size();i++){",
		  "        hashh = ((hashh*multiplier)%mod + s[i])%mod;",
		  "      //  DEBUG(hashh);",
		  "    }",
		  "",
		  "    return hashh;",
		  "}",
		  "",
		  "vl getHashVector(string &s, ll m = p1, ll multiplier = 999999893){",
		  "    vector <ll> hashVector(s.size());",
		  "",
		  "    hashVector[0] = s[0];",
		  "    // DEBUG(s[0]);",
		  "    // DEBUG( hashVector[0]);",
		  "     for(int i = 1;i<s.size();i++){",
		  "        hashVector[i] = (hashVector[i-1]*multiplier + s[i])%m;",
		  "        //   DEBUG(s[i]);",
		  "        // DEBUG( hashVector[i]);",
		  "    }",
		  "",
		  "    return hashVector;",
		  "}",
		  "",
		  "ll substringHash(vl &hashVector, ll a, ll b, ll m ,unordered_map<ll,ll> &primePower){",
		  "    if(a == 0){",
		  "        return hashVector[b];",
		  "    }",
		  "    return ((hashVector[b] - (hashVector[a-1]*primePower[b-a+1])%m)%m+m)%m;",
		  "}",
		  ""
		],
		"description": "Rolling hash"
	  },

	  "Custom hash to make unordered map faster": {
		"prefix": "_custom_hash_map",
		"body": [
		  "struct custom_hash {",
		  "    static uint64_t splitmix64(uint64_t x) {",
		  "        // http://xorshift.di.unimi.it/splitmix64.c",
		  "        x += 0x9e3779b97f4a7c15;",
		  "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
		  "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
		  "        return x ^ (x >> 31);",
		  "    }",
		  "",
		  "    size_t operator()(uint64_t x) const {",
		  "        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
		  "        return splitmix64(x + FIXED_RANDOM);",
		  "    }",
		  "};"
		],
		"description": "Custom hash to make unordered map faster"
	  },
 
 
}